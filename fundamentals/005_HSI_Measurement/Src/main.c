/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

//

#define RCC_BASE_ADDR 0x40021000UL
#define RCC_CFGR_OFFSET 0x08UL
#define RCC_CFGR_REG_ADDR (RCC_BASE_ADDR + RCC_CFGR_OFFSET)
#define GPIOA_BASE_ADDR 0x48000000UL

//

int main(void)
{

    uint32_t *pRCC_CFGR_REG = (uint32_t *)RCC_CFGR_REG_ADDR;

    //* 1. Configure the Clock Source RCC_CFGR Bits 27:24 to 0011: HSI16 clock selected 
    //! We are writing the value 0x53000000 the in memory address in pRCC_CFGR_REG

    *pRCC_CFGR_REG = 0x53000000; // &= ~(0x3 << 24); // clear 24 and 25 bit position 0x5000 0000

    //* Clock Pre-scaler set to 4 -> Bits 30:28 : 010: MCO is divided by 4

    *pRCC_CFGR_REG |= (0x0 << 28);

    //* This exercise does not in the L4 because we cannot use the PA8 for the MCO, it is already beinging used by USBOTG

    //* 2. Configure PA8 to AF0 mode to behave as MCO signal

    //* a) Enable the Peripheral Clock (RCC) for GPIOA peripheral connect to AHB2 BUS

    uint32_t *pRCC_AHB2_ENR = (uint32_t *)(RCC_BASE_ADDR + 0x4C);
    *pRCC_AHB2_ENR |= (1 << 0);

    //* b) Configure the mode of the GPIOA pin 5 as alternate function mode : GPIOx_MODER

    uint32_t *pGPIOAModeReg = (uint32_t *)(GPIOA_BASE_ADDR + 0x00);

    //! 0x3 = 10 then shifted to the left by 16 bits, where 16 is the first bit postion of MODE8
    *pGPIOAModeReg &= ~(0x3 << 10); // Clear
    *pGPIOAModeReg |= (0x2 << 10);  // Set

    //* c) Configure the alternation function register to set the mode 0 for PA8 : (GPIOx_AFRH)

    uint32_t *pGPIOAAltFunHighReg = (uint32_t *)(GPIOA_BASE_ADDR + 0x24);
    *pGPIOAAltFunHighReg &= ~(0xF << 0);

    /* Loop forever */
    for (;;);
}
